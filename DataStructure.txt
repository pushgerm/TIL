
ch.1 자료구조와 알고리즘의 이해

* 자료구조에 대한 기본적인 이해

프로그램이란 데이터를 표현(자료구조)하고, 그렇게 표현된 데이터를
처리(알고리즘)하는 것이다.
선형구조 - 리스트, 스택, 큐
비선형구조 - 트리, 그래프
파일구조 - 순차파일, 색인파일, 직접파일
단순구조 - 정수, 실수, 문자, 문자열

* 알고리즘의 성능분석 방법

= 자료구조의 성능분석 방법
알고리즘을 평가하는 두 가지 요소
시간 복잡도(time complexity) -> 얼마나 빠른가?(CPU)
공간 복잡도(space complexity) -> 얼마나 메모리를 적게 쓰는가?(memory)
시간 복잡도를 더 중요시 한다.(메모리를 많이 접근할수록 시간이 걸리므로)
평가 방법 : 중심이 되는 특정 연산의 횟수를 세어서 평가한다.
주변 연산자의 연산횟수는 중심연산자의 연산횟수에 의존적이다
중심연산자 연산횟수 <= 주변 연산자의 연산 횟수

순차 탐색 평균적 경우 시간 복잡도:
가정 1 : 탐색 대상이 배열에 존재하지 않을 확률 50%
가정 2 : 배열 첫 요소부터 마지막 요소까지 탐색 대상 존재 확률 동일!
탐색 대상이 존재하지 않는 해경우의 연산횟수는 n : n개의 데이터 중에 찾고자 하는 데이터가 없으면 n번 모두 탐색 해야 하므로 n
가정 2에 의해서 탐색 대상이 존재하는 경우의 연산횟수는 n/2 : n개의 데이터 중에 최대 n번, 최소 1번만 하면 되므로 중간값인 n/2번.
그러므로 각 경우가 될 확률이 1/2이므로 n*1/2 + n/2*1/2 = T(n)이 된다.

이진 탐색 알고리즘
배열이 정렬되어 있어야 한다는 제약이 따른다.
1. 배열 인덱스의 시작과 끝은 각각 0과 8이다.
2. 0과 8을 합하여 그 결과를 2로 나눈다.
3. 2로 나눠서 얻은 결과 4를 인덱스 값으로 하여 arr[4]에 저장된 값을 확인한다.

n x (1/2)^k = 1 : n을 몇번 반으로 나눠야 1이 되는가? k가 나눠야 하는 횟수를 말한다.
위 식 변형해서  T(n) = log2 n : 시간 복잡도의 목적은 n의 값에 따른 T(n)의 증가 및 감소의 정도를 판단하는 것이므로 +1은 생략 가능.
그렇다면 +100도 생략이 가능한가?
T(n)에서 실제로 영향력을 끼치는 부분을 가리켜 빅-오 라 한다.
T(n)이 다항식으로 표현이 된 경우, 최고차항의 차수가 빅-오가 된다.
T(n) = an^m+bn^m-1 .....이면 O(n^m).
f(n) <= Cg(n) 을 만족하게 한느 두 개의 상수 C와 K가 존재한다면
f(n) 의 빅-오는O(g(n))이다.

-----------------------------------------------------------------------------

ch2. 재귀


1. 함수의 재귀적 호출의 이해

2. 재귀의 활용

함수 = 호출관계 + 호출순서//호출관계에 집중해라


3. 하노이 타워

목적 : 큰 원반 n개를 A에서 C로 이동
 1 : 작은 원반 n-1개를 A에서 로 이동
 2 : 큰 원반 1개를 A에서 C로 이동
 3 : 작은 원반 n-1개를 B에서 C로 이동

--------------------------------------------------------------------------

ch3, 4, 5. 연결 리스트

1. 추상 자료형(ADT : Abstract Data Type)

구체적인 기능의 완성과정을 언급하지 않고, 순수하게 기능이 무엇인지를 나열한 것.
ex) 지갑의 추상 자료형 : 카드의 삽입, 추출. 동전의 삽입, 추출.

구조체의 Data들과 관련된 함수가 정의된다.
그래서 구조체 이외에서 . 이나 ->의 연산자가 사용되지 않도록 해줘야 한다.
결국 함수로 데이터를 가지고 놀자.

자료구조 학습의 옳은 순서
	1. 리스트 자료구조의 ADT를 정의한다.
	2. ADT를 근거로 리스트 자료구조를 활용하는 main함수를 정의한다.
	3. ADT를 근거로 리스트를 구현한다.


2. 배열을 이용한 연결 리스트의 구현

### typedef 와 #define 의 차이. 
#define은 단순 치환이며 자료형을 선언해주지는 못하지만, typedef는 새로운 자료형을 선언할 수 있다.

배열 기반 리스트의 단점
	배열의 길이가 초기에 결정되어야 한다. 변경이 불가능하다.
	삭제의 과정에서 데이터의 이동(복사)가 매우 빈번히 일어난다.
배열 기반 리스트의 장점
	데이터 참조가 쉽다. 인덱스 값 기준으로 어디든 한 번에 참조 가능.

3. 연결리스트의 개념적인 이해

동적할당에 대한 이해! malloc free
배열의 장점 : 순차접근이 쉽다.index를 통해.
배열의 단점 : 크기가 결정되어야 한다.

typedef struct _node{
int data;	//데이터를 담을 공간
struct _node* next;	// 연결의 도구
} Node;


데이터 입력
		printf("자연수 입력: ");
		scanf("%d", &readData);
		if(readData < 1)
			break;

		/*** 노드의 추가과정 ***/
		newNode = (Node*)malloc(sizeof(Node));
		newNode->data = readData;
		newNode->next = NULL;

		if(head == NULL)
			head = newNode;
		else
			tail->next = newNode;

		tail = newNode;




데이터 출력
	if(head == NULL) 
	{
		printf("저장된 자연수가 존재하지 않습니다. \n");
	}
	else 
	{
		cur = head; 
		printf("%d  ", cur->data);   // 첫 번째 데이터 출력
		
		while(cur->next != NULL)    // 두 번째 이후의 데이터 출력
		{
			cur = cur->next;
			printf("%d  ", cur->data);
		}
	}
	printf("\n\n");





데이터 삭제//앞에서 부터 순차적으로 삭제해 나감
	if(head == NULL)
	{
		return 0;    // 해제할 노드가 존재하지 않는다.
	}
	else
	{
		Node * delNode = head;
		Node * delNextNode = head->next;

		printf("%d을(를) 삭제합니다. \n", head->data);
		free(delNode);    // 첫 번째 노드의 삭제

		while(delNextNode != NULL)    // 두 번째 이후의 노드 삭제 위한 반복문
		{
			delNode = delNextNode;
			delNextNode = delNextNode->next;

			printf("%d을(를) 삭제합니다. \n", delNode->data);
			free(delNode);    // 두 번째 이후의 노드 삭제
		}
	}


4. 단순 연결 리스트의 ADT와 구현

새 노드를 연결 리스트의 머리에 추가하는 경우
장점 : 포인터 변수 tail이 불필요하다. //마지막 데이터의 위치를를 몰라도 되기 때문.
단점 : 저장된 순서를 유지하지 않는다.

새 노드를 연결 리스트의 꼬리에 추가하는 경우
장점 : 저장된 순서가 유지된다. 
단점 : 포인터 변수 tail이 필요하다. 

유효한 정보를 가지고 있지 않은 더미노드를 만들어주자
기존에 첫 번쨰 노드와 두 번째 이후의 노드 추가 및 삭제 방식은 구분되어 있었다.
하지만 더미노드를 추가 함으로써 추가 및 삭제 방식을 합칠 수 있다.



5. 연결 리스트의 정렬 삽입의 구현


6. 원형 연결 리스트

꼬리가 머리를 가리키면 그것이 바로 원형 연결 리스트.
원형 연결 리스트는 머리와 꼬리의 구분이 없다.
기존의 연결리스트는 head와 tail이 필요했지만 원형연결리스트에선 head가 필요가 없고 tail은 경우에 따라 필요하다.
**단순 연결 리스트처럼 머리와 꼬리를 가리키는 포인터 변수를 각각 두지 않아도,
하나의 포인터 변수만 있어도 머리 또는 꼬리에 노드를 간단히 추가할 수 있다.**
꼬리를 가리키는 포인터 편수는? tail
머리를 가리키는 포인터 변수는? tail->next
꼬리에 노드를 추가하려면 꼬리의 주소값을, 머리에 노드를 추가하려면 머리의 주솟값을 알아야 하는데 원형연결리스트에서는 tail만 있어도 head의 주소값을 알 수 있다.

7. 양방향 연결 리스트


----------------------------------------------------------------------------

ch6. 스택(Stack)


1. 스택의 이해와 ADT의 정의

먼저 들어간 것이 나중에 나오는 자료구조. (Last-in, First-out)
push : 데이터를 넣는다.
pop : 데이터를 꺼낸다. (데이터 추출 + 삭제)
peek : 이번에 꺼낼 데이터가 무엇인지 확인만 한다.

정의

void StackInit(Stack* pstack);
스택의 초기화를 진행한다.
스택 생성 후 제일 먼저 호출되어야 하는 함수이다

int SIsEmpty(Stack* pstack);
스택이 빈 경우 TRUE(1)를, 그렇지 않은 경우 FALSE(0)를 반환한다.

void SPush(Stack* pstack, Data data);
스택에 데이터를 저장한다. 매개변수 data로 전달된 값을 저장한다.

Data SPop(Stack* pstack);
마지막에 저장된 요소를 삭제한다.
삭제된 데이터는 반환이 된다.
본 함수의 호출을 위해서는 데이터가 하나 이상 존재함이 보장되어야 한다.

Data SPeek(Stack* pstack);
마지막에 저장된 요소를 반환하되 삭제하지 않는다.
본 함수의 호출을 위해서는 데이터가 하나 이상 존재함이 보장되어야 한다.

2. 스택의 배열 기반 구현

인덱스가 0인 위치를 스택의 바닥으로 정의해야 배열 길이에 상관없이 바닥의 인덱스 값이 동일해진다.

딱히 특이한 내용 없음

3. 스택의 연결 리스트 기반 구현

원형연결리스트를 이용한 스택의 구현//꼭 해보기
원형연결리스트의 헤더파일과 소스파일은 건드리지 않는다.
stack.h, stack.c만 구현해 주면 된다.

4. 계산기 프로그램 구현

중위 표기법 : 수식 내에 연산의 순서에 대한 정보가 담겨 있지 않다. 그래서 소괄호와 연산자의 우선순위라는 것을 정의하여 이를 기반으로 연산의 순서를 명시한다.

전위 표기법 : 수식 내에 연산의 순서에 대한 정보가 담겨 있다. 그래서 소괄호가 필요 없고 연산의 우선순위를 결정할 필요도 없다.

후위 표기법 : 전위 표기법과 마찬가지로 수식 내에 연산의 순서에 대한 정보가 담겨 있다. 그래서 소괄호가 필요 없고 연산의 우선순위를 결정할 필요도 없다.

---------------------------------------------------------------------------

# ch7. 큐(Queue)

1. 큐의 이해와 ADT 정의

- 큐는 LIFO(Last-in, First-out)구조의 자료구조이다. 때문에 먼저 들어간 것이 먼저 나오는, 일종의 '줄서기'에 비유할 수 있는 자료구조이다.

- enqueue : 큐에 데이터를 넣는 연산
- depueue : 큐에서 데이터를 꺼내는 연산

- 큐는 운영체제 관점에서 보면 프로세스나 쓰레드의 관리에 활용이 되는 자료구조이다. 이렇듯 운영체제의 구현에도 자료구조가 사용이 된다. 따라서 운영체제의 이해를 위해서는 자료구조에 대한 이해가 선행되어야 한다.

void QueueInit(Queue* pq);
- 큐의 초기화를 진행한다.
- 큐 생성 후 제일 먼저 호출되어야 하는 함수이다.

역시F(삭제)와 R(삽입)을 가지고 구성

초기화에 NULL로 초기화 해주지 않는 상황도 있다.

# 4. 큐의 활용

점심시간 1시간 동안에는 고객이 15초당 1명씩 주문을 한다.
종류별 햄버거를 만드는데 걸리는 시간은 다음과 같다.
치즈버거 : 12초
불고기버거 : 15초
더블버거 : 24초
시뮬레이션 할 상황 : 이 상황에서 대기실의 크기를 결정하는데 필요한 정보를 추출하는 것이 목적!

30명 -> 수용확률 50%
50명 -> 70%
100명 -> 90%
200명 -> 100%

- 점심시간은 1시간이고 그 동안 고객은 15초에 1명씩 주문을 하는 것으로 간주한다.
- 한 명의 고객은 하나의 버거 만을 주문한다고 가정한다.
- 주문하는 메뉴에는 가중치를 두지 않는다. 모든 고객은 무작위로 메뉴를 선택한다.
- 햄버거를 만드는 사람은 1명이다. 그리고 동시에 둘 이상의 버거가 만들어지지 않는다.
- 주문한 메뉴를 받을 다음 고객은 대기실에서 나와서 대기한다.


# 5. 덱(Deque)의 이해와 구현

디큐로 읽지 않고 덱으로 읽자(dequeue연산과 발음이 같다)
double ended queue
양쪽 방향으로 넣을수도 뺄 수도 있다.( 스택 + 큐 //애매함)

앞으로 넣기, 앞으로 빼기
뒤로 넣기, 뒤에서 빼기

Deque는 double ended queue의 줄인 표현으로, 양쪽 방향으로 모두 입출력이 가능함을의미한다. 그리고 스택과 큐의 특성을 모두 지니고 있다고도 말한다.(의견일뿐) 덱을 스택으로도 큐로도 활용할 수 있기 때문이다.

Data Dequeue(Queue* pq);
- 저장순서가 가장 앞선 데이터를 삭제한다.
- 삭제된 데이터는 반환된다.
- 본 함수의 호출을 위해서는 데이터가 하나 이상 존재함이 보장되어야 한다.

Data QPeek(Queue*pq);
- 저장순서가 가장 앞선 데이터를 반환하되 삭제하지 않는다.
- 본 함수의 호출을 위해서는 데이터가 하나 이상 존재함이 보장되어야 한다.

# 2. 큐의 배열 기반 구현

Front(dequeue)와 Rear(enqueue)로 구성한다.
배열기반으로 구성하면 길이의 한계가 있기 때문에 보편적으로 원형 큐로 구현한다.

F와 R이 같은 위치를 가르키면 빈 상태로 표시하면
R==F : Empty
R+1 ==F : Full

# 3. 큐의 연결 리스트 기반 구현

역시F(삭제)와 R(삽입)을 가지고 구성

초기화에 NULL로 초기화 해주지 않는 상황도 있다.

# 4. 큐의 활용

점심시간 1시간 동안에는 고객이 15초당 1명씩 주문을 한다.
종류별 햄버거를 만드는데 걸리는 시간은 다음과 같다.
치즈버거 : 12초
불고기버거 : 15초
더블버거 : 24초
시뮬레이션 할 상황 : 이 상황에서 대기실의 크기를 결정하는데 필요한 정보를 추출하는 것이 목적!

30명 -> 수용확률 50%
50명 -> 70%
100명 -> 90%
200명 -> 100%

- 점심시간은 1시간이고 그 동안 고객은 15초에 1명씩 주문을 하는 것으로 간주한다.
- 한 명의 고객은 하나의 버거 만을 주문한다고 가정한다.
- 주문하는 메뉴에는 가중치를 두지 않는다. 모든 고객은 무작위로 메뉴를 선택한다.
- 햄버거를 만드는 사람은 1명이다. 그리고 동시에 둘 이상의 버거가 만들어지지 않는다.
- 주문한 메뉴를 받을 다음 고객은 대기실에서 나와서 대기한다.


# 5. 덱(Deque)의 이해와 구현

디큐로 읽지 않고 덱으로 읽자(dequeue연산과 발음이 같다)
double ended queue
양쪽 방향으로 넣을수도 뺄 수도 있다.( 스택 + 큐 //애매함)

앞으로 넣기, 앞으로 빼기
뒤로 넣기, 뒤에서 빼기

Deque는 double ended queue의 줄인 표현으로, 양쪽 방향으로 모두 입출력이 가능함을의미한다. 그리고 스택과 큐의 특성을 모두 지니고 있다고도 말한다.(의견일뿐) 덱을 스택으로도 큐로도 활용할 수 있기 때문이다.

void DequeInit(Deque* pdeq);
- 덱의 초기화를 진행한다.
- 덱 생성 후 제일 먼저 호출되어야 하는 함수이다.

int DQIsEmpty(Deque*pdeq);
- 덱이 빈 경우 TRUE를, 그렇지 않은 경우 FALSE를 반환한다.

void DQAddFirst(Deque* pdeq, Data data);
- 덱의 머리에 데이터를 저장한다. data로 전달된 값을 저장한다.

void DQAddLast(Deque* pdeq, Data data);
- 덱의 꼬리에 데이터를 저장한다. data로 전달된 값을 저장한다.

Data DQRemoveFirst(Deque* pdeq);
- 덱의 머리에 위치한 데이터를 반환 및 소멸한다.

Data DQRemoveLast(Deque* pdeq);
- 덱의 꼬리에 위치한 데이터를 반환 및 소멸한다.

Data DQGetFirst(Deque* pdeq);
- 덱의 머리에 위치한 데이터를 소멸하지 않고 반환한다.

Data DqGetLast(Deque* pdeq);
덱의 꼬리에 위치한 데이터를 소멸하지 않고 반환한다.

덱의 구현에 가장 어울리는 자료구조는 양방향 연결 리스트이다.


---------------------------------------------------------------------------


ch8. 트리

# 1. 트리의 개요

트리는 계층적 관계를 표현하는 자료구조이다.

노드(node) : 트리의 구성요소에 해당하는 A, B, C, D, E, F와 같은 요소
간선(edge) : 노드와 노드를 연결하는 연결선
루트 노드(root node) : 트리 구조에서 최상위에 존재하는 A와 같은 노드
단말 노드(terminal node) : 아래로 또 다른 노드가 연결되어 있지 않은 E, F, D, D와 같은 노드
내부 노드(internal node) : 단말 노드를 제외한 모든 노드로 A, B와 같은 노드

   -E
 -B-F
A-C
 -D

노드 A는 노드 B, C, D의 부모 노드이다.
노드 B, C, D는 노드 A의 자식 노드이다.
노드 B, C, D는 부모 노드가 같으므로, 서로가 서로에게 형제 노드 이다.

서브 트리의 이해
서브 트리 역시 서브 트리로 이뤄져 있으며, 그 서브 트리 역시 또 다른 서브 트리로 이뤄져 있다. 이렇듯 트리는 그 구조가 재귀적이다. 

이진 트리의 이해
이진 트리의 조건
- 루트 노드를 중심으로 두 개의 서브 트리로 나뉘어진다.
-나뉘어진 두 서브 트리도 모두 이진 트리어야 한다.
"이진 트리가 되려면, 루트 노드를 중심으로 둘로 나뉘는 두 개의 서브 트리도 이진 트리이어야 하고, 그 서브 트리의 모든 서브 트리도 이진 트리이어야 한다."
공집합(empty set)도 이진 트리에서는 노드로 간주한다.

하나의 노드에 두 개 까지 노드를 달 수 있으면 이진 트리이다.

루트노드를 레벨0, 루트노드의 자식노드를 레벨1, 그 밑으로 내려갈 때마다 레벨이 0부터 증가한다.
높이는 앳지를 카운트한다. 
높이 = 최대레벨

완전 이진 트리는 위에서 아래로 왼쪽에서 오른쪽으로 채워진 트리를 의미한다.
따라서 포화 이진 트리는 동시에 완전 이진 트리이지만 그 역은 성립하지 않는다.

# 2. 이진 트리의 구현

이진 트리 구현의 두 가지 방법

1. 노드에 번호를 부여하고 그 번호에 해당하는 값을 배열의 인덱스 값으로 활용한다.. 편의상 배열의 첫 번째 요소는 사용하지 않는다.
2. 연결 리스트 기반에서는 트리의 구조와 리스트의 연결 구조가 일치한다. 따라서 구현과 관련된 직관적인 이해가 더 좋은 편이다.

완전 이진 트리의 순서대로 번호를 매긴다.

헤더파일에 정의된 구조체의 이해
typedef struct _bTreeNode
{
	BTData data;
	struct _bTreeNode* left;
	struct _bTreeNode* right;
} BTreeNode;//이진 트리의 노드이자 트리를 표현한 구조체

헤더파일에 선언된 함수들
BTreeNode* MakeBTreeNode(void);//노드의 생성
BTData GetData(BTreeNode* bt);//노드에 저장된 데이터를 반환
void SetData(BTreeNode* bt, BTData data);//노드에 데이터를 저장
BTreeNode* GetLeftSubTree(BTreeNode* bt);// 왼쪽 서브 트리의 주소 값 반환
BTreeNode* GetRightSubTree(BTreeNode* bt);//오른쪽 서브 트리의 주소 값 반환
루트 노드를 포함하여 어떠한 노드의 주소 값도 인자로 전달될 수 있다.
전달된 노드의 왼쪽, 오른쪽 '서브 트리의 루트 노드 주소 값' 또는 그냥 '노드의 주소 값'이 반환된다.
void MakeLeftSubTree(BTreeNode* main, BTreeNode* sub);//main의 서브 왼쪽 서브트리로 sub를 연결
void MakeRightSubTree(BTreeNode* main, BTreeNode* sub);// main의 오른쪽 서브 트리로 sub를 연결
하나의 노드도 일종의 이진 트리이다. 따라서 위와 같이 함수를 이름을 짓는 것이 타당하다.
위의 함수들은 단순히 노드가 아니라 트리를 대상으로도 그 결과를 보인다는 사실을 기억하자.

# 3. 이진 트리의 순회(Traversal)

중위 순회 : 왼쪽 -> 루트 -> 오른쪽
후위 순회 : 왼쪽 -> 오른쪽 -> 루트
전위 순회 : 루트 -> 왼쪽 -> 오른쪽

중위 순회
1단계 : 왼쪽 서브 트리의 순회
2단계 : 루트 노드의 방문
3단계 : 오른쪽 서브 트리의 순회
void InorderTraverse(BTreeNode* bt)
{
	if(bt==NULL)
		return;
	InorerTraverse(BTreeNode* bt)
	printf("%d \n", bt->data);
	InorderTraverse(bt->right);//중위순회
}순서만 바꾸면 전위 순회, 후위 순회가 된다.

typedef void VisitFuncPtr(BTData data);//함수의 포인터형이 된다.
이렇게 쓸 수 있다.
void InorderTraverse(BTreeNode* bt, VisitFuncPtr action)//함수의 주소값을 진자로 전달하는데 그 함수는 반환형이 void이고 매개변수 타입이 BTData이어야 한다.
{
중위순회
}

# 4. 수식 트리(Expression Tree)의 구현

내부 노드에 +-*/등의 수식이 들어있는 트리.

중위 표기법의 수식 -> 후위 표기법의 수식 -> 수식 트리 구현

BTreeNode* MakeExpTree(char exp[]);//수식 트리 구성
int EvaluateExpTree(BTreeNode* bt);// 수식 트리 계산
void ShowPrefixTypeExp(BTreeNode* bt);//전위 표기법 기반 출력
void ShowInfixTypeExp(BTreeNode* bt);// 중위 표기법 기반 출력
void ShowPostfixTypeExp(BTreeNode* bt);//후위 표기법 기반 출력

후위 표기법의 수식 1 2 + 7 * = ( 1 + 2 ) * 7
후위 표기법의 수식에서 먼저 등장하는 피연산자와 연산자를 이용해서 트리의 하단부터 구성해 나가고 이어서 점진적으로 윗부분을 구성해 나간다.

--------------------------------------------------------------------------

ch 9. 우선순위 큐


# 1. 우선순위 큐의 이해

큐 : 선입선출

우선순위 큐
들어간 순서와 나가는 순서에 관계가 없다. 이진트리의 연장선상이다.

순위
A : 1
B : 2
C : 3
어떤 데이터가 먼저 들어가던 상관 없이 우선순위대로 출력한다.

enqueue : 우선순위 큐에 데이터를 삽입하는 행위
dequeue : 우선순위 큐에서 데이터를 꺼내느 행위
들어간 순서에 상관 없이 우선순위를 근거로 dequeue 연산이 진행된다.
데이터 별 우선순위의 비교기준은 프로그래머가 결정할 몫이다! 따라서 우선순위 큐 자료구조를 활용하는 프로그래머가 직접 우선순위 비교기준을 결정할 수 있도록 구현이 되어야 한다.

힙 : 이진트리의 일종. *완전 이진 트리* 이다.

최대 힙 : 모든 노드에 저장된 값은 자식 노드에 저장된 값보다 크거나 같아야 한다. 즉 루트 노드에 저장된 값이 가장 커야 한다.

최소 힙 : 모든 노드에 저장된 값은 자식 노드에 저장된 값보다 작거나 같아야 한다. 즉 루트 노드에 저장된 값이 가장 커야 한다.


# 2. 힙의 구현과 우선순위 큐의 완성

우선순위 큐는 힙이다 x
힙는 우선순위 큐이다 x 
힙은 우선순위 큐를 구현하기 위한 도구(방법)이다 o

1. 자식 노드 데이터의 우선순위 <= 부모 노드 데이터의 우선순위
2. 새 데이터는 우선순위가 낮다는 가정하에 끝에 저장. 그리고 부모 노드와 비교를 진행
3. 부모 노드와 비교 및 자리바꿈
4. 반복

힙에서의 데이터 삭제과정

루트 노드의 삭제만 생각한다. 가장 상단에 우선 순위가 높은 데이터가 있기 때문.
1. 마지막 노드를 루트노드에 삽입.
2. 자식 노드와 비교 후 이동
3. 반복

삽입과 삭제의 과정에서 보인 성능의 평가

-배열 기반 데이터 삽입의 시간 복잡도 O(n)
-배열 기반 데이터 삭제의 시간 복잡도 O(1)

-연결 리스트 기반 데이터 삽입의 시간 복잡도 O(n)
-연결 리스트 기반 데이터 삭제의 시간 복잡도 O(1)

-힙 기반 데이터 삽입의 시간 복잡도 O(log2 n)
-힙 기반 데이터 삭제의 시간 복잡도 O(log2 n)

왼쪽 자식 노드의 인덱스 값 = 부모 노드의 인덱스 값 * 2 
오른쪽 자식 노드의 인덱스 값 = 부모 노드의 인덱스 값 * 2 + 1
부모 노드의 인덱스 값 = 왼쪽 자식 노드의 인덱스 값 / 2

헤더 파일의 소개
typedef char HData;
typedef int Priority;

typedef struct _heapElem{
	Priority pr;
	Hdata datal
} HeapElem;

typedef struct _heap{
	int numOfData;
	HeapElem heapArr[HEAP_LEN];
}Heap;

void HeapInit(Heap* ph);
int HIsEmpty(HEAP* ph);
void HInsert(Heap* ph, Hdata data, Priority pr);
HData HDelete(Heap* ph);

원리 이해 중심의 힙 구현 : 숙지할 내용
- 힙은 완전 이진 트리이다.
- 힙의 구현은 배열을 기반으로 하며 인덱스가 0인 요소는 비워둔다.
- 따라서 '힙에 저장된 노드의 개수와 마지막 노드의 고유번호는 일치한다.'
- 노드의 고유번호가 노드가 저장되는 배열의 인덱스 값이 된다.
- 우선순위를 나타내는 정수 값이 작을수록 높은 우선순위를 나타낸다고 가정한다.

배열을 기반으로 하는 경우 힙에 저장된 노드의 개수와 마지막 노드의 고유번호가 일치하기 때문에 마지막 노드의 인덱스 값을 쉽게 얻을 수 있다.







